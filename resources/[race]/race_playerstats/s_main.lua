g_StatsReset = falselocal hasRespawn = falselocal hasCheckpoints = falselocal isMapTimeout = falselocal currentRacestate = ""local playersFinished = {}local function displayWelcomeMessage(player)	local welcomeMessage = tostring(Settings["welcomeMessage"].value or "")	if welcomeMessage:len() > 0 then		alert(welcomeMessage, "chat", player)	endend-- tell the client to show the stats panellocal function displayStatsPanel(player, playerName)	if Settings["showStatsOnMapFinish"].value then		playerName = playerName or getPlayerName(player)				triggerClientEvent(player, "onClientUpdateStats", resourceRoot, playerName, PlayerData[playerName].Stats)		-- 'source' is set to resourceRoot to signal automatic panel display		triggerClientEvent(player, "onClientStatsDisplay", resourceRoot, true)	endendlocal function hideStatsPanel(player)	triggerClientEvent(player, "onClientStatsDisplay", resourceRoot, false)end-- loads the stats table from db, and stores it on a tablefunction handle_PlayerJoin(player)	player = player or source		local playerName = getPlayerName(player)	InitializePlayerData(playerName)	-- load from db	PlayerData[playerName].Stats = LoadPlayerStats(player) or {}	BatchApplyPedStats(player, PlayerData[playerName].Stats)endaddEventHandler("onPlayerJoin", root, 	function()		handle_PlayerJoin()		displayWelcomeMessage(source)	end)-- store saved stats to db when player leavesfunction handle_PlayerQuit(player)	local playerName = getPlayerName(source or player)	if not playerName then playerName = getPlayerName(player) end		local ticks = PlayerData[playerName].JoinTime or 0	if ticks > 0 then		local playingTime = getTickCount() - ticks		IncrementPlayerStatInternal(playerName, Stat.PLAYING_TIME, playingTime / 1000)	end	-- save to db		SavePlayerStats(playerName, PlayerData[playerName].Stats)	PlayerData[playerName] = nilendaddEventHandler("onPlayerQuit", root, handle_PlayerQuit)function handle_PlayerChangeNick(oldNick, newNick)	-- outputDebugString("Player changing nick")	local ticks = PlayerData[oldNick] and PlayerData[oldNick].JoinTime or 0	if ticks > 0 then		local playingTime = getTickCount() - ticks		IncrementPlayerStatInternal(oldNick, Stat.PLAYING_TIME, playingTime / 1000)	end	-- save to db		SavePlayerStats(oldNick, (PlayerData[oldNick] and PlayerData[oldNick].stats or {}))	PlayerData[oldNick] = nil	InitializePlayerData(newNick)	-- load from db	PlayerData[newNick].Stats = LoadPlayerStats(newNick) or {}	BatchApplyPedStats(source, PlayerData[newNick].Stats)endaddEventHandler("onPlayerChangeNick", root, handle_PlayerChangeNick)addEventHandler("onResourceStart", resourceRoot, 	function()		local players = getElementsByType("player")		for _,player in ipairs(players) do			handle_PlayerJoin(player)		end	end)-- tell everyone to save their statsaddEventHandler("onResourceStop", resourceRoot, 	function()		local players = getElementsByType("player")		for _,player in ipairs(players) do			handle_PlayerQuit(player)		end	end)addEvent("onMapStarting", true)addEventHandler("onMapStarting", root, 	function(mapInfo, mapOptions, gameOptions)		hasRespawn = (tostring(mapOptions["respawn"]) == "timelimit")		hasCheckpoints = false		isMapTimeout = false		g_StatsReset = false		playersFinished = {}		local players = getElementsByType("player")		for _,player in ipairs(players) do			BatchApplyPedStats(player, (PlayerData[getPlayerName(player)] and PlayerData[getPlayerName(player)].stats or {}))		end	end)addEvent("onRaceStateChanging")addEventHandler("onRaceStateChanging", root,	function(newState, oldState)		currentRacestate = newState		if oldState == "GridCountdown" and newState == "Running" then			for _,player in ipairs(getActivePlayers()) do				IncrementPlayerStatInternal(player, Stat.TOTAL_RACES, 1)			end			return		end		if newState == "TimesUp" then			isMapTimeout = true		end	end)-- player joined mid-race?addEventHandler("onNotifyPlayerReady", root, 	function()		hideStatsPanel(source)		if Settings["countMidraceJoinAsRacestart"].value and (currentRacestate == "Running" or currentRacestate == "MidMapVote") then			IncrementPlayerStatInternal(source, Stat.TOTAL_RACES, 1)		end		BatchApplyPedStats(source, PlayerData[getPlayerName(source)].Stats)	end)-- tell everyone to save their stats when a map endsaddEventHandler("onResourceStop", resourceRoot,	function()		local players = getElementsByType("player")		for _,player in ipairs(players) do			local playerName = getPlayerName(player)						if PlayerData[playerName] then				local ticks = PlayerData[playerName].JoinTime or 0				if ticks > 0 then					local playingTime = getTickCount() - ticks					IncrementPlayerStatInternal(player, Stat.PLAYING_TIME, playingTime / 1000)					PlayerData[playerName].JoinTime = getTickCount()				end					SavePlayerStats(player, PlayerData[playerName].Stats)			end			end	end) addEventHandler("onVehicleDamage", root, 	function(damage)	    local player = getVehicleOccupant(source)	    -- Check there is a player in the vehicle	    if player then	    	IncrementPlayerStatInternal(player, Stat.DAMAGE_TAKEN, math.floor(damage))	    end	end)-- player is dead, so show stats panel while it waitsaddEventHandler("onPlayerWasted", root,	function(ammo, attacker, weapon, bodypart)		if not (playersFinished[source] and not Settings["countPostFinishDeath"].value) then			IncrementPlayerStatInternal(source, Stat.TIMES_DIED, 1)		end		if not hasRespawn then			triggerEvent("onPlayerRaceFinish", source)			displayStatsPanel(source)		end	end)-- this is used to check which vehicle the player was driving when it diedaddEvent("onPlayerRaceWasted", true)addEventHandler("onPlayerRaceWasted", root, 	function(vehicle)		local playerName = getPlayerName(source)		PlayerData[playerName].VehicleId = getElementModel(vehicle)				if getElementHealth(vehicle) > Settings["vehicleWreckHealthLimit"].value then return end -- wasn't on fire		local statKey = getDestroyedVehicleStatKey(PlayerData[playerName].VehicleId)		if statKey ~= nil then			IncrementPlayerStatInternal(source, statKey, 1)		end	end)addEvent("onPlayerReachCheckpoint", true)addEventHandler("onPlayerReachCheckpoint", root,	function(checkpointNum, time)		hasCheckpoints = true		IncrementPlayerStatInternal(source, Stat.CHECKPOINTS_COLLECTED, 1)	end)addEvent("onPlayerFinish")addEventHandler("onPlayerFinish", root,	function(rank, time)		hasCheckpoints = true		playersFinished[source] = true		IncrementPlayerStatInternal(source, Stat.CHECKPOINTS_COLLECTED, 1)			-- this event is only triggered by the final checkpoint		IncrementPlayerStatInternal(source, Stat.RACES_FINISHED, 1)		if rank == 1 then			IncrementPlayerStatInternal(source, Stat.RACES_WON, 1)			triggerEvent("onPlayerRaceWin", source)		end				triggerEvent("onPlayerRaceFinish", source, rank, time)		displayStatsPanel(source)	end)addEvent("onPostFinish")addEventHandler("onPostFinish", root, 	function()		-- only for DD mode (no respawn, no checkpoints)		if hasRespawn or hasCheckpoints then return end				-- map timed out, so nobody won		if isMapTimeout then			alert("Map Timeout!")			--triggerEvent("onRaceTimeout", root)			return 		end		local currentRank = 255		local winner = nil		local players = getElementsByType("player")		for i,player in ipairs(players) do			local rank = tonumber(getElementData(player, "race rank", false)) or 255			alert(getPlayerName(player) .. " rank = "..tostring(rank))			if rank < currentRank then				currentRank = rank				winner = player			end		end		if winner and currentRank == 1 then			alert("Winner is " .. getPlayerName(winner))			IncrementPlayerStatInternal(winner, Stat.RACES_FINISHED, 1)			IncrementPlayerStatInternal(winner, Stat.RACES_WON, 1)						triggerEvent("onPlayerRaceFinish", source)			triggerEvent("onPlayerRaceWin", winner)						displayStatsPanel(winner)		end	end)addEvent("onPlayerToptimeImprovement")addEventHandler("onPlayerToptimeImprovement", root, 	function(newPos, newTime, oldPos, oldTime)		if newPos == 1 then			IncrementPlayerStatInternal(source, Stat.TOPTIMES_SET, 1)		end	end)---- EVENTS--addEvent("onPlayerRaceFinish")addEvent("onPlayerRaceWin")-- This event is triggered by the client when it wishes to be sent the stats for a given player.addEvent("onRequestPlayerStats", true)addEventHandler("onRequestPlayerStats", root, 	function(playerName)		playerName = playerName or getPlayerName(source)		triggerClientEvent(source, "onClientUpdateStats", source, playerName, PlayerData[playerName].Stats)	end)-- this event is triggered by the client when it sends stats changesaddEvent("onBulkUpdateStats", true)addEventHandler("onBulkUpdateStats", root, 	function(statsTable)		-- skip any stats update in case of a stats reset		-- this flag will be disabled on next map start		if g_StatsReset then return end				for stat,amount in pairs(statsTable) do			IncrementPlayerStatInternal(source, stat, amount)		end	end)addEvent("onUpdateStat", true)addEventHandler("onUpdateStat", root, 	function(stat, value)		IncrementPlayerStatInternal(source, stat, value)	end)